[HTTP/HTTPS]

인코딩 : 0과 1로 문자를 표현하는 것 (일종의 약속들) >> 아스키(Ascii) & 유니코드(Unicode)
아스키 : 7비트 데이터에 대한 인코딩 표
유니코드 : 한 문자는 최대한 32개의 비트로 표현
인코딩을 통해 우리의 문장을 컴퓨터에 저장하고 표현

통신 프로토콜📃
웹 서버에 있는 리소스를 클라이언트가 받아 보려면, 클라이언트는 웹에게 특정 리소스를 지정하여 제공해달라고 요청.
서버가 해당 요청을 잏하고, 대응되는 동작을 통해 클라이언트에게 리소스를 반환하는데 여기서 클라이언트의 행위를 요청(Request), 서버의 행위를 응답(Response)이라고 함.
프로토콜은 일반적으로 규격화된 상호작용에 적용되는 약속을 말함.
컴퓨터와 통신에 있어서 비교적 엄격한 프로토콜을 사용해야 함. 왜냐하면 컴퓨터는 해석의 융통성을 발휘하는 것이 매우 어렵고, 이 과정에서 통신 오류가 발생할 가능성을 높일 수 있기 때문.
컴퓨터 통신 프로토콜은 각 통신 주체가 교환하는 데이터를 명확히 해석할 수 있도록 문법(syntax)을 포함.
문법에 어긋나는 메시지는 잘못 전송된 것으로 취급하여 무시함.
현재까지 제정된 표준 통신 프로토콜에는 네트워크 통신의 기초가 되는 TCP/IP, 웹이 사용하는 HTTP, 파일을 주고받을 때 사용하는 FTP 등 매우 많은 종류가 존재.

HTTP란 서버와 클라이언트의 데이터 교환을 요청과 응답 형식으로 정의한 프로토콜
기본 메커니즘은 클라이언트가 서버에게 요청하면, 서버가 응답하는 것.
웹 서버는 HTTP 서버를 HTTP 서비스 포트에 대기시키고 이 포트는 일반적으로 TCP/80 or TCP/8080
클라이언트가 서비스 포트에 HTTP 요청을 전송하면, 이를 해석하여 적절한 응답으로 반환.

네트워크 포트 : 네트워크에서 서버와 클라이언트가 정보를 교환하는 추상회단 장소 ( 일명 포트 )
서비스 포트 : 네트워크 포토 중에서 특정 서비스가 점유하고 있는 포트 ex) HTTP가 80번 포트를 점유하고 있다면 HTTP의 서비스 포트는 80번 포트가 됨.
포트로 데이터를 교환하는 방식은 전송 계층의 프로토콜을 따름. 대표적으로 TCP와 UDP가 있음
TCP로 데이터를 전송하려는 서비스에 UDP 클라이언트가 접근하면, 데이터가 교환되지 않음. 반대의 경우도 마찬가지
서비스 포트를 표기할 때는 전송 계층 프로토콜을 같이 표기하기도 함.
현대의 윈도우나 리눅스, 맥 운영체제는 0번 부터 65535번까지,, 총 65536개의 같은 수의 네트워크 포트를 사용함.

포트 중 0번부터 1023번 포트는 잘 알려진 포트(Well-known port) 또는 특권 포트(Privileged port)라고 함.
대표적으로 22번 포트에는 SSH, 80에는 HTTP, 443에는 HTTPS가 할당되어 있는 것 처럼 각 폰트 번호에 유명한 서비스가 등록되어 있음.
잘 알려진 포트에 서비스를 실행하려면 관리자 권한이 필요함으로 클라이언트는 이 대역에서 실행 중인 서비스들은 관리자의 것이라고 신뢰할 수 있음.

HTTP 메시지에는 클라이언트가 전송하는 HTTP 요청, 그리고 서버가 반환하는 HTTP 응답이 있음.
이들은 HTTP 헤더와 바디로 구성된다는 공통점이 존재

HTTP 헤더
- 각 줄은 CRLF로 구분되며, 첫 줄은 시작 줄, 나머지 줄은 헤더라고 부름.
- 영문 표기에서는 Headers와 Header이지만, 한국어에서는 모두 헤더로 부름.
- 헤더의 끝은 빈 줄로 나타냄.
- 필드와 값으로 구성되며 HTTP 메시지 또는 바디의 속성을 나타냄.
- 하나의 HTTP 메시지에는 0개 이상의 헤더가 있을 수 있음.

HTTP 바디
- 헤드의 끝을 나타내는 CRLF 뒤 모든 줄을 말함.
- 클라이언트나 서버에게 전송하려는 데이터가 바디에 담김.

CRLF란?
- Carriage Return (CR)와 Line Feed (LF)의 조합
- CR은 커서를 현재 줄의 맨 앞으로 이동시키는 문자
- LF는 커서를 다음 줄로 이동시키는 문자
- 이것들은 주로 텍스트 파일에서 줄 바꿈을 나타내는 데 사용되는 제어 문자열
- 윈도우 운영체제에서는 줄을 종결시키기 위해 CRLF를 사용하고, 리눅스같은 유닉스 기반 운영체제에서는 LF만을 사용.

HTTP 요청
- HTTP 요청은 서버에게 특정 동작을 요구하는 메시지
- 서버는 해당 동작이 실현 가능한지, 클라이언트가 그러한 동작을 요청할 권한이 있는지 등을 검토 후 적절할 때 이를 처리.

HTTP 요청의 시작 줄은 메소드, 요청 대상, 그리고 HTTP 버전으로 구성 / 각각은 띄어쓰기로 구분

메소드 : 요청 대상에 대해 서버가 수행하길 바라는 동적을 나타냄. HTTP 표준에 정의된 메소드는 8개가 존재
GET 메소드 : 리소스를 가져와달라 요청하는 메소드 
ㄴ 이용자가 브라우저에 웹 서버의 주소를 입력하ㅓ나 하이퍼링크를 클릭하면, 새로운 페이지를 렌더링하기 위해 리소스가 필요한데 이때 GET 요청을 서버에 전송하여 리소스를 받아옴.
POST 메소드 : 요청 대상에게 데이터를 보내는 메소드
ㄴ 전송할 데이터는 보통 HTTP 바디에 포함됨. ID와 비밀번호, 게시판에 작성하는 글 등이 POST로 서버에 보내짐.

HTTP 응답 : HTTP 요청에 대한 결과를 반환하는 메시지
ㄴ 요청을 수행했는지, 하지 않았는지, 안 했다면 이유는 무엇인지와 같은 상태 정보, 그리고 클라이언트에게 전송할 리소스가 응답에 포함됨.

시작 줄 : HTTP 버전, 상태 코드, 처리 사유로 구성. / 각각은 띄어쓰기로 구분
- HTTP 버전 : 서버에서 사용하는 HTTP 프로토콜의 버전을 나타냄.
- 상태 코드 : 요청에 대한 처리결과를 세 자릿수로 나타냄. ( HTTP 표준인 RFC 2616은 대략 40여개의 상태 코드를 정의하고 있고, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 분류 )
- 처리 사유 : 상태 코드가 발생한 이유를 짧게 기술한 것.

(상태코드)
1xx : 요청을 제대로 받았고, 처리가 진행 중
2xx : 요청이 제대로 처리됨
3xx : 요청을 처리하려면, 클라이언트가 추가 동작을 취해야 함.
4xx : 클라이언트가 잘못된 요청을 보내어 처리에 실패
5xx : 클라이언트의 요청은 유효하지만, 서버에 에러가 발생하여 처리에 실패

HTTPS 
- HTTPS의 응답과 요청은 평문으로 전달됨.
- HTTPS는 TLS(Transport Layer Security) 프로토콜을 도입하여 공격자가 중간에 중요한 정보를 가로채는 문제점을 보완함.
- TLS는 서버와 클라이언트 사이에 오가는 모든 HTTP 메시지를 암호화 함.
- 공격자가 중간에 메시지를 탈취하더라도 해석하는 것은 불가능하며, 결과적으로 HTTP 통신이 도청과 변조로부터 보호됨.
   ㄴ TLS의 기반은 공개 키 암호 시스템 및 대칭 키 암호. > HTTPS의 메시지는 복호화 할 수 있는 키가 없다면 해석 불가.
웹 서버의 URL이 httl://로 시작되면 HTTP, https://로 시자가되면 HTTPS 프로토콜을 사용함.

일상에서 우리가 웹 페이지를 방문하기 위해 HTTP 요청을 보낸 적도, 응답을 받아 해석한 적도 없는 이유는 크롬, 사파리, 파이어폭스로 대표되는 웹 브라우저 덕분.

